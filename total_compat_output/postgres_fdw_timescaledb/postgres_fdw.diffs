diff -U3 /home/abigalek/pgext-cli/postgresql-15.3/contrib/postgres_fdw/expected/postgres_fdw.out /home/abigalek/pgext-cli/postgresql-15.3/contrib/postgres_fdw/results/postgres_fdw.out
--- /home/abigalek/pgext-cli/postgresql-15.3/contrib/postgres_fdw/expected/postgres_fdw.out	2023-05-08 21:13:20.000000000 +0000
+++ /home/abigalek/pgext-cli/postgresql-15.3/contrib/postgres_fdw/results/postgres_fdw.out	2023-11-26 04:14:22.984190567 +0000
@@ -5815,17 +5815,17 @@
          Output: CASE WHEN (random() >= '0'::double precision) THEN d.c2 ELSE 0 END, d.ctid, d.*, t.*
          Relations: (public.ft2 d) INNER JOIN (public.ft2 t)
          Remote SQL: SELECT r1.c2, r1.ctid, CASE WHEN (r1.*)::text IS NOT NULL THEN ROW(r1."C 1", r1.c2, r1.c3, r1.c4, r1.c5, r1.c6, r1.c7, r1.c8) END, CASE WHEN (r2.*)::text IS NOT NULL THEN ROW(r2."C 1", r2.c2, r2.c3, r2.c4, r2.c5, r2.c6, r2.c7, r2.c8) END FROM ("S 1"."T 1" r1 INNER JOIN "S 1"."T 1" r2 ON (((r1."C 1" = r2."C 1")) AND ((r1."C 1" > 1000)))) FOR UPDATE OF r1
-         ->  Hash Join
+         ->  Merge Join
                Output: d.c2, d.ctid, d.*, t.*
-               Hash Cond: (d.c1 = t.c1)
+               Merge Cond: (d.c1 = t.c1)
                ->  Foreign Scan on public.ft2 d
                      Output: d.c2, d.ctid, d.*, d.c1
                      Remote SQL: SELECT "C 1", c2, c3, c4, c5, c6, c7, c8, ctid FROM "S 1"."T 1" WHERE (("C 1" > 1000)) ORDER BY "C 1" ASC NULLS LAST FOR UPDATE
-               ->  Hash
+               ->  Materialize
                      Output: t.*, t.c1
                      ->  Foreign Scan on public.ft2 t
                            Output: t.*, t.c1
-                           Remote SQL: SELECT "C 1", c2, c3, c4, c5, c6, c7, c8 FROM "S 1"."T 1"
+                           Remote SQL: SELECT "C 1", c2, c3, c4, c5, c6, c7, c8 FROM "S 1"."T 1" ORDER BY "C 1" ASC NULLS LAST
 (17 rows)
 
 UPDATE ft2 d SET c2 = CASE WHEN random() >= 0 THEN d.c2 ELSE 0 END
@@ -10906,15 +10906,15 @@
          ->  Async Foreign Scan on public.async_p2 async_pt_2
                Output: async_pt_2.a, async_pt_2.b, async_pt_2.c
                Remote SQL: SELECT a, b, c FROM public.base_tbl2 WHERE (($1::integer = a))
-         ->  Seq Scan on public.async_p3 async_pt_3
+         ->  Index Scan using async_p3_idx on public.async_p3 async_pt_3
                Output: async_pt_3.a, async_pt_3.b, async_pt_3.c
-               Filter: (local_tbl.a = async_pt_3.a)
+               Index Cond: (async_pt_3.a = local_tbl.a)
 (15 rows)
 
 EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
 SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
+                                    QUERY PLAN                                     
+-----------------------------------------------------------------------------------
  Nested Loop (actual rows=1 loops=1)
    ->  Seq Scan on local_tbl (actual rows=1 loops=1)
          Filter: (c = 'bar'::text)
@@ -10922,8 +10922,8 @@
    ->  Append (actual rows=1 loops=1)
          ->  Async Foreign Scan on async_p1 async_pt_1 (never executed)
          ->  Async Foreign Scan on async_p2 async_pt_2 (actual rows=1 loops=1)
-         ->  Seq Scan on async_p3 async_pt_3 (never executed)
-               Filter: (local_tbl.a = a)
+         ->  Index Scan using async_p3_idx on async_p3 async_pt_3 (never executed)
+               Index Cond: (a = local_tbl.a)
 (9 rows)
 
 SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
